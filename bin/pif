#!/usr/bin/env ruby
# encoding: UTF-8

lib = File.expand_path("../../lib", __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

# require 'pp'
require_relative '../lib/pif/parser'
require_relative '../lib/pif/converter'

input_file_path = ARGV[0]
output_dir = ARGV[1]
flag = ARGV[2]
output_format = ARGV[3]

valid_output_formats = ["rs", "pif"]

if input_file_path && output_dir
  # Check for calid flag and output_format
  if flag && output_format
    if flag != "-f" || !valid_output_formats.include?(output_format)
      puts "Unknown flag or format used"
    end
  end

  filename = File.basename(input_file_path, File.extname(input_file_path))

  puts "Parsing #{filename}.peml ..."
  file = File.open(input_file_path, "r:UTF-8")
  content = file.read
  parsed = Peml.pif_parse({ pif: content })
  value = parsed[:value].dottie!
  diagnostics = parsed[:diagnostics];
  puts "Parsing complete..."

  has_nontrivial_blocklist = value["assets.code.blocks.content"]
                               &.any? { |block| block["blocklist"] && !block["pickone"] }
  if has_nontrivial_blocklist
    puts "This file has a blocklist but doesnt have a blocklist pickone value"
  end

  if (diagnostics.length == 0 && !has_nontrivial_blocklist)
    File.open("#{output_dir}/#{filename}.json", 'w') do |file|
      # PIF File is parsed to fit runestone parsons as the default for now.
      # The option to select a specific parsons version
      # or native PIF will be added soon
      case output_format
      when "pif"
        file.puts(parsed.to_json)
      when "rs"
        puts "Converting to rs format..."
        file.puts(PifConverter.to_runestone(parsed[:value], "json"))
      else
        puts "Converting to rs format..."
        file.puts(PifConverter.to_runestone(parsed[:value], "json"))
      end
    end
  end

else
  puts "Usage: pif <filename> <output directory> \n flag -f : Output format"
  exit 1
end

